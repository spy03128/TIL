# let, const 키워드와 블록 레벨 스코프

## var 키워드로 선언한 변수의 문제점

ES5까지 변수를 선언할 수 있는 유일한 방법은 `var` 키워드를 사용하는 것이었음

`var` 키워드로 선언된 변수는 다른 언어와는 구별되는 독특한 특징이 있으며 주의를 기울이지 않으면 심각한 문제를 발생시킬 수 있음

### 1. 변수 중복 선언 허용

`var` 키워드로 선언한 변수는 중복 선언이 가능함

```jsx
var x = 1;
var y = 1;

var x = 100; //초기화문이 있는 변수는 var 키워드가 없는 것처럼 동작함
var y; //초기화문이 없는 변수 선언문은 무시됨

console.log(x); //100
console.log(y); //1
```

초기화문이 있는 변수 선언문은 자바스크립트 엔진에 의해 `var` 키워드가 없는 것처럼 동작하고 초기화문이 없는 변수 선언문은 무시되며 이때 에러는 발생하지 않음

### 2. 함수 레벨 스코프

`var` 키워드로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정함. 따라서 함수 외부에서 `var` 키워드로 선언한 변수는 코드 블록 내에서 선언해도 모두 전역 변수가 됨

```jsx
var x = 1;

if (true) {
  var x = 10;
}

console.log(x); //10
```

for문의 변수 선언문에서 `var` 키워드로 선언한 변수도 전역변수가 됨

```jsx
var i = 10;

for (var i = 0; i < 5; i++) {
  console.log(i); // 0 1 2 3 4
}

console.log(i); //5
```

### 3. 변수 호이스팅

`var` 키워드로 변수를 선언하면 변수 호이스팅에 의해 변수 선언문이 스코프의 선두로 끌어 올려진 것처럼 동작함

즉, 변수 호이스팅에 의해 `var` 키워드로 선언한 변수는 변수 선언문 이전에 참조할 수 있음

단 할당문 이전에 변수를 참조하면 언제나 `undefined` 를 반환함

```jsx
//이 시점에는 변수 호이스팅에 의해 이미 foo 변수가 선언됨
//변수 foosms undefined로 초기화됨
console.log(foo); //undefined

//변수에 값을 할당
foo = 123;

console.log(foo); //123

//변수 선언은 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 실행됨
var foo;
```

## let 키워드 특징

`var` 키워드의 단점을 보완하기 위해 ES6에서는 새로운 변수 선언 키워드인 `let` 과 `const` 를 도입함

### 1. 변수 중복 선언 금지

`var` 키워드로 이름이 동일한 변수를 중복 선언하면 아무런 에러가 발생하지 않음. 이때 변수를 중복 선언하면서 값까지 할당했다면 의도치않게 먼저 선언된 변수 값이 재할당되어 변경되는 부작용이 발생

하지만 `let` 키워드로 이름이 같은 변수를 중복 선언하면 에러가 발생함

```jsx
var foo = 123;

var foo = 456;

let bar = 123;

let bar = 456; //SyntaxError
```

### 2. 블록 레벨 스코프

`var` 키워드로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정하는 함수 레벨 스코프를 따름

하지만 `let` 키워드로 선언한 변수는 모든 코드 블록을 지역 스코프로 인정하는 블록 레벨 스코프를 따름

```jsx
let foo = 1; //전역 변수

{
  let foo = 2; //지역 변수
  let bar = 3; //지역 변수
}

console.log(foo); //1
console.log(bar); // ReferenceError
```

`let` 키워드로 선언된 변수는 블록 레벨 스코프를 따름. 따라서 블록 내에서 선언된 `foo` 와 `bar` 변수는 지역 변수이며 전역에서 선언된 `foo` 변수와 코드 블록 내에서 선언된 `foo` 변수는 다른 별개의 변수임

### 3. 변수 호이스팅

`var` 키워드로 선언한 변수와 달리 `let` 키워드로 선언한 변수는 변수 호이스팅이 발생하지 않는 것처럼 동작함

```jsx
console.log(foo); //ReferenceError
let foo;
```

`let` 키워드로 선언한 변수를 변수 선언문 이전에 참조하면 참조에러가 발생함. `var` 키워드는 런타인 이전에 자바스크립트 엔진에 의해 암묵적으로 `선언 단계`와 `초기화 단계`가 한번에 진행됨. undefined로 선언 즉시 초기화 되었다가 변수 할당문에 도달하면 비로소 값이 할당됨.

그러나 `let` 키워드로 선언한 변수는 `선언 단계`와 `초기화 단계`가 분리되어 진행됨.

즉, 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 선언 단계가 먼저 실행되지만 초기화 단계는 변수 선언문에 도달했을 때 실행됨.

만약 초기화 단계가 실행되기 이전에 변수에 접근하려고 하면 참조 에러가 발생하며 `let` 키워드로 선언한 변수는 스코프의 시작 시점부터 초기화 단계 시작 지점까지 변수를 참조할 수 없으며 이를 `일시적 사각지대` 라고 부름.

```jsx
console.log(foo); //ReferenceError

let foo; //변수 선언문에서 초기화 단계가 실행됨
console.log(foo); //undefined

foo = 1; //할당문에서 할당 단계가 실행됨
console.log(foo); //1
```

결국 `let` 키워드로 선언한 변수는 변수 호이스팅이 발생하지 않는 것처럼 보이지만 그렇지 않음

```jsx
let foo = 1; //전역 변수

{
  console.log(foo); //ReferenceError
  let foo = 2; //지역 변수
}
```

`let` 키워드로 선언한 변수의 경우 변수 호이스팅이 발생하지 않는다면 위 예제는 전역 변수 `foo` 값을 출력해야하지만 `let` 키워드로 선언한 변수도 여전히 호이스팅이 발생하기때문에 참조에러가 발생함

자바스크립트 ES6에서는 모든 선언을 호이스팅함. 다만 `let` , `const` , `class` 를 사용한 선언문은 호이스팅이 발생하지 않는것처럼 동작함
