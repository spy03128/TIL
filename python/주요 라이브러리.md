### 내장함수

```python
result = sum([1,2,3,4,5])
print(result)
#15

result = min(7,3,5,2)
print(result)
#2

result = max(7,3,5,2)
print(result)
#7

result = eval("(3+5) * 7")
print(result)
#56

result = sorted([9,1,8,5,4])
print(result)
#[1,4,5,8,9]

result = sorted([9,1,8,5,4], reverse = True)
print(result)
#[9,8,5,4,1]

result = sorted([('홍길동',35), ('이순신',75), ('아무개',50)], key = lambda x: x[1], reverse = True)
print(result)
#[('이순신',75), ('아무개',50), ('홍길동',35)]

data = [9, 1, 8, 5, 4]
data.sort()
print(data)
#[1,4,5,8,9]
```

### itertools

파이썬에서 반복되는 데이터를 처리하는 기능을 포함하고 있는 라이브러리

대표적 : 순열 `permutations` 조합 `combinations`

**순열(permutations)**: iterable 객체에서 r개의 데이터를 뽑아 일렬로 나열하는 모든 경우(순열)를 계산

리스트 [’A’, ‘B’, ‘C’]에서 3개를 뽑아 나열하는 모든 경우의 수 출력

```python
from itertools import permutations

data = ['A','B','C']

result = list(permutations(data,3))
print(result)
#[('A','B','C'), ('A','C','B'), ('B','A','C'), ('B','C','A'), ('C','A','B'), ('C','B','A')]
```

**중복순열(product)**: iterable 객체에서 r개의 데이터를 뽑아 일렬로 나열하는 모든 경우(순열)를 계산, 다만 원소를 중복하여 뽑음

리스트 [’A’, ‘B’, ‘C’]에서 중복을 포함하여 2개를 뽑아 나열하는 모든 경우의 수 출력

```python
from itertools import product

data = ['A','B','C']

result = list(permutations(data,3))
print(result)
#[('A','A'), ('A','B'), ('A','C'), ('B','A'), ('B','B'), ('B','C'), ('C','A'), ('C','B'), ('C','C')]
```

**조합(combinations)**: iterable 객체에서 r개의 데이터를 뽑아 순서를 고려하지 않고 나열하는 모든 경우를 계산

리스트 [’A’, ‘B’, ‘C’]에서 3개를 뽑아 순서에 상관없이 나열하는 모든 경우의 수 출력

```python
from itertools import combinations

data = ['A','B','C']

result = list(combinations(data,2))
print(result)
#[('A','B'), ('A','C'), ('B','C')]
```

**중복조합(combinations)**: iterable 객체에서 r개의 데이터를 뽑아 순서를 고려하지 않고 나열하는 모든 경우를 계산, 다만 원소를 중복하여 뽑음

리스트 [’A’, ‘B’, ‘C’]에서 중복을 포함하여 2개를 뽑아 순서에 상관없이 나열하는 모든 경우의 수 출력

```python
from itertools import combinations_with_replacement

data = ['A','B','C']

result = list(combinations_with_replacement(data,2))
print(result)
#[('A','A'), ('A','B'), ('A','C'), ('B','B'), ('B','C'), ('C','C')]
```

### heapq

heapq는 다익스트라 최단 경로 알고리즘을 포함해 다양한 알고리즘에서 우선순위 큐 기능을 구현하고자 할 때 사용 PriorityQueue 라이브러리를 사용할 수 있지만 코딩 테스트 환경에서는 보통 heapq가 더 빠르게 동작함.

파이썬의 힙은 최소 힙으로 구성되어 있어 단순히 원소를 넣었다가 빼는 것만으로도 시간 복잡도 O(NlogN)에 오름차순 정렬이 완료됨. 원소 삽입시 `heapq.heqppush()` 힙에서 원소를 꺼낼 때 `heapq.heappop()` 

**최소힙**

```python
import heapq

def heapsort(iterable):
	h = []
	result = []
	#모든 원소를 차례대로 힙에 삽입
	for value in iterable:
		heapq.heappush(h, value)
	
	#힙에 삽입된 모든 원소를 차례대로 꺼내어 담기
	for i in range(len(h)):
		result.append(heapq.heappop(h))
	return result

result = heapsort([1,3,5,7,9,2,4,6,8,0)
print(result)

# [0,1,2,3,4,5,6,7,8,9]
```

**최대힙 : 지원하지 않음. 최소힙에서 부호를 변경하여 구현**

```python
import heapq

def heapsort(iterable):
	h = []
	result = []
	#모든 원소를 차례대로 힙에 삽입
	for value in iterable:
		heapq.heappush(h, -value)
	
	#힙에 삽입된 모든 원소를 차례대로 꺼내어 담기
	for i in range(len(h)):
		result.append(-heapq.heappop(h))
	return result

result = heapsort([1,3,5,7,9,2,4,6,8,0)
print(result)

# [9,8,7,6,5,4,3,2,1,0]
```